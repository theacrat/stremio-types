diff --git a/.gitignore b/.gitignore
index ca4998e4..dfef34c1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,4 +7,5 @@
 **/stremio_core_web.js
 **/bridge.js
 **/worker.js
-**/stremio_core_web_bg.wasm
\ No newline at end of file
+**/stremio_core_web_bg.wasm
+**/bindings
\ No newline at end of file
diff --git a/Cargo.toml b/Cargo.toml
index c96fc89a..09214d54 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -37,6 +37,7 @@ analytics = []
 deflate = ["stremio-official-addons/deflate"]
 
 [dependencies]
+ts-rs = {version = "11.1", features = ["serde-compat", "no-serde-warnings", "format", "url-impl", "bytes-impl", "chrono-impl", "semver-impl"]}
 stremio-derive = { path = "stremio-derive" }
 stremio-watched-bitfield = { path = "stremio-watched-bitfield" }
 stremio-official-addons = "=2.1.1"
@@ -57,7 +58,7 @@ flate2 = "1"
 futures = "0.3"
 
 http = "1.2"
-url = { version = "2.4", features = ["serde"] }
+url = { version = "^2.4", features = ["serde"] }
 percent-encoding = "2.1"
 
 # Time
@@ -68,7 +69,7 @@ base64 = "0.22"
 sha1 = "0.10"
 sha2 = "0.10"
 
-either = "1.6"
+either = "^1.6"
 enclose = "1.1"
 derivative = "2.2"
 derive_more = { version = "2", features = ["from", "into", "into_iterator", "try_into", "deref"] }
@@ -77,7 +78,7 @@ strum = { version = "0.27", features = ["derive"] }
 
 lazysort = "0.2"
 
-once_cell = "1"
+once_cell = "^1"
 itertools = "0.14"
 
 magnet-url = "3.0"
diff --git a/src/constants.rs b/src/constants.rs
index 6382d639..03d6d75f 100644
--- a/src/constants.rs
+++ b/src/constants.rs
@@ -2,6 +2,8 @@ use std::collections::HashMap;
 
 use once_cell::sync::Lazy;
 use percent_encoding::{AsciiSet, NON_ALPHANUMERIC};
+use serde::{Deserialize, Serialize};
+use stremio_derive::ts_prepare;
 use url::Url;
 
 use crate::types::addon::{Descriptor, ExtraProp, OptionsLimit};
@@ -141,3 +143,37 @@ pub static TYPE_PRIORITIES: Lazy<HashMap<&'static str, i32>> = Lazy::new(|| {
     .into_iter()
     .collect()
 });
+
+#[ts_prepare(export)]
+#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash)]
+#[serde(rename_all = "camelCase")]
+pub enum ContentType {
+    All,
+    Channel,
+    Movie,
+    Other,
+    Series,
+    Tv,
+}
+
+#[ts_prepare(export)]
+#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash)]
+#[serde(rename_all = "camelCase")]
+pub enum ExtraType {
+    CalendarVideosIds,
+    Genre,
+    LastVideosIds,
+    Search,
+    Skip,
+}
+
+#[ts_prepare(export)]
+#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash)]
+#[serde(rename_all = "snake_case")]
+pub enum ResourceType {
+    AddonCatalog,
+    Catalog,
+    Meta,
+    Stream,
+    Subtitles,
+}
diff --git a/src/types/addon/descriptor.rs b/src/types/addon/descriptor.rs
index 9e5239d8..4527a672 100644
--- a/src/types/addon/descriptor.rs
+++ b/src/types/addon/descriptor.rs
@@ -1,8 +1,10 @@
 use crate::types::addon::{Manifest, ManifestPreview};
 use serde::{Deserialize, Serialize};
+use stremio_derive::ts_prepare;
 use url::Url;
 
 /// Addon descriptor
+#[ts_prepare(export, rename = "Addon")]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct Descriptor {
@@ -28,6 +30,7 @@ impl From<&Descriptor> for DescriptorPreview {
     }
 }
 
+#[ts_prepare(rename = "AddonFlags")]
 #[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct DescriptorFlags {
diff --git a/src/types/addon/manifest.rs b/src/types/addon/manifest.rs
index 78de531c..319d685e 100644
--- a/src/types/addon/manifest.rs
+++ b/src/types/addon/manifest.rs
@@ -5,15 +5,17 @@ use derive_more::Deref;
 use either::Either;
 use serde::{Deserialize, Deserializer, Serialize};
 use serde_with::{serde_as, DefaultOnError, DefaultOnNull, DeserializeAs, NoneAsEmptyString};
+use stremio_derive::ts_prepare;
 use url::Url;
 
-use crate::constants::SKIP_EXTRA_PROP;
+use crate::constants::{ContentType, ExtraType, ResourceType, SKIP_EXTRA_PROP};
 use crate::types::addon::{ExtraValue, ResourcePath};
 use crate::types::{UniqueVec, UniqueVecAdapter};
 
 /// Re-export the semver::Version
 pub use semver::Version;
 
+#[ts_prepare(export)]
 #[serde_as]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[cfg_attr(test, derive(Derivative))]
@@ -40,6 +42,7 @@ pub struct Manifest {
     /// if they have been set, i.e. [`Option::Some`]!
     ///
     /// Types examples: `movie`, `series`, `anime`, `other`, `tv`, etc.
+    #[ts(as = "Vec<ContentType>")]
     pub types: Vec<String>,
     /// # Resources
     ///
@@ -231,16 +234,20 @@ impl From<&Manifest> for ManifestPreview {
 ///     assert_eq!(ManifestResource::Full { name: "no-types".into(), types: None, id_prefixes: Some(vec![]) }, manifest_resource);
 /// }
 /// ```
+#[ts_prepare]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(untagged)]
 pub enum ManifestResource {
     /// Short resource format defines only the `name` of the resource
+    #[ts(as = "ResourceType")]
     Short(String),
     #[serde(rename_all = "camelCase")]
     Full {
+        #[ts(as = "ResourceType")]
         name: String,
         /// The types should be a subset of the ones defined in [`Manifest::types`].
         #[serde(default)]
+        #[ts(as = "Option<Vec<ContentType>>")]
         types: Option<Vec<String>>,
         /// The id prefixes should be a subset of the ones defined in [`Manifest::id_prefixes`].
         ///
@@ -267,11 +274,14 @@ impl ManifestResource {
     }
 }
 
+#[ts_prepare]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct ManifestCatalog {
     pub id: String,
     /// E.g. `movie`, `series`
+    ///
+    #[ts(as = "ContentType")]
     pub r#type: String,
     pub name: Option<String>,
     #[serde(flatten)]
@@ -338,6 +348,7 @@ impl UniqueVecAdapter for ManifestCatalogUniqueVecAdapter {
     }
 }
 
+#[ts_prepare]
 #[serde_as]
 #[derive(Derivative, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
 #[derivative(Default)]
@@ -354,9 +365,11 @@ pub enum ManifestExtra {
     Short {
         #[serde(default, rename = "extraRequired")]
         #[serde_as(deserialize_as = "UniqueVec<Vec<_>, ExtraPropShortUniqueVecAdapter>")]
+        #[ts(as = "Vec<ExtraType>")]
         required: Vec<String>,
         #[serde(default, rename = "extraSupported")]
         #[serde_as(deserialize_as = "UniqueVec<Vec<_>, ExtraPropShortUniqueVecAdapter>")]
+        #[ts(as = "Vec<ExtraType>")]
         supported: Vec<String>,
     },
 }
@@ -380,10 +393,12 @@ impl ManifestExtra {
     }
 }
 
+#[ts_prepare]
 #[serde_as]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct ExtraProp {
+    #[ts(as = "ExtraType")]
     pub name: String,
     #[serde(default)]
     pub is_required: bool,
@@ -439,6 +454,7 @@ impl Default for OptionsLimit {
     }
 }
 
+#[ts_prepare]
 #[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct ManifestBehaviorHints {
diff --git a/src/types/resource/meta_item.rs b/src/types/resource/meta_item.rs
index 47164b52..415818fb 100644
--- a/src/types/resource/meta_item.rs
+++ b/src/types/resource/meta_item.rs
@@ -12,6 +12,7 @@ use serde_with::{
     formats::PreferMany, serde_as, DefaultOnNull, DeserializeAs, NoneAsEmptyString, OneOrMany,
     PickFirst, TimestampMilliSeconds,
 };
+use stremio_derive::ts_prepare;
 use url::Url;
 
 use crate::constants::{
@@ -30,7 +31,8 @@ pub type MetaItemId = String;
 
 pub type MetaItemType = String;
 
-#[derive(Clone, PartialEq, Deserialize, Debug)]
+#[ts_prepare]
+#[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[cfg_attr(test, derive(Default))]
 struct Trailer {
     source: String,
@@ -53,9 +55,9 @@ impl<'de> DeserializeAs<'de, Trailer> for Stream {
     }
 }
 
+#[ts_prepare(export, rename = "MetaItemPreview")]
 #[serde_as]
-#[derive(Clone, PartialEq, Deserialize, Debug)]
-#[cfg_attr(test, derive(Default))]
+#[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug, Default)]
 #[serde(rename_all = "camelCase")]
 struct MetaItemPreviewLegacy {
     id: MetaItemId,
@@ -241,12 +243,14 @@ impl From<MetaItemPreviewLegacy> for MetaItemPreview {
     }
 }
 
+#[ts_prepare]
 #[serde_as]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[cfg_attr(test, derive(Default))]
 #[serde(rename_all = "camelCase")]
 pub struct MetaItem {
     #[serde(flatten)]
+    #[ts(skip)]
     pub preview: MetaItemPreview,
     #[serde(default)]
     #[serde_as(
@@ -255,6 +259,17 @@ pub struct MetaItem {
     pub videos: Vec<Video>,
 }
 
+#[ts_prepare(export, rename = "MetaItem")]
+#[allow(dead_code)]
+#[derive(Serialize)]
+#[serde(rename_all = "camelCase")]
+struct MetaItemLegacy {
+    #[serde(flatten)]
+    pub item: MetaItem,
+    #[serde(flatten)]
+    pub preview: MetaItemPreviewLegacy,
+}
+
 impl MetaItem {
     /// Returns an iterator over references to Video, skipping special episodes, sorted by released and series_info, oldest first
     pub fn videos_iter(&self) -> impl DoubleEndedIterator<Item = &Video> {
@@ -282,6 +297,7 @@ impl MetaItem {
     }
 }
 
+#[ts_prepare]
 #[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub enum PosterShape {
@@ -292,6 +308,7 @@ pub enum PosterShape {
     Poster,
 }
 
+#[ts_prepare]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[cfg_attr(test, derive(Default))]
 pub struct SeriesInfo {
@@ -304,6 +321,7 @@ pub struct SeriesInfo {
 /// For example when using the id as key in a [`HashMap`].
 pub type VideoId = String;
 
+#[ts_prepare]
 #[serde_as]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[cfg_attr(test, derive(Default))]
@@ -389,6 +407,7 @@ impl SortedVecAdapter for VideoSortedVecAdapter {
     }
 }
 
+#[ts_prepare]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 pub struct Link {
     pub name: String,
@@ -396,6 +415,7 @@ pub struct Link {
     pub url: Url,
 }
 
+#[ts_prepare]
 #[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct MetaItemBehaviorHints {
@@ -406,5 +426,6 @@ pub struct MetaItemBehaviorHints {
     #[serde(default)]
     pub has_scheduled_videos: bool,
     #[serde(flatten)]
+    #[ts(skip)]
     pub other: HashMap<String, serde_json::Value>,
 }
diff --git a/src/types/resource/stream.rs b/src/types/resource/stream.rs
index be75117b..8b2ec216 100644
--- a/src/types/resource/stream.rs
+++ b/src/types/resource/stream.rs
@@ -1,6 +1,7 @@
 use core::fmt;
 use std::{collections::HashMap, io::Write};
 
+use stremio_derive::ts_prepare;
 use tracing::trace;
 
 use base64::Engine;
@@ -13,6 +14,7 @@ use magnet_url::Magnet;
 use percent_encoding::utf8_percent_encode;
 use serde::{de::Error, Deserialize, Deserializer, Serialize};
 use serde_with::{serde_as, DefaultOnNull, VecSkipError};
+use ts_rs::TS;
 use url::{form_urlencoded, Url};
 
 use stremio_serde_hex::{SerHex, Strict};
@@ -62,6 +64,7 @@ use crate::{runtime::EnvError, types::streams::ConvertedStreamSource};
 ///
 /// assert_eq!(null_fields, expected_stream);
 /// ```
+#[ts_prepare(concrete(S = StreamSource), bound = "S::OptionInnerType: TS")]
 #[serde_as]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
@@ -752,6 +755,7 @@ impl Stream {
 ///
 /// pretty_assertions::assert_eq!(streams, expected);
 /// ```
+#[ts_prepare]
 #[serde_as]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[cfg_attr(test, derive(derivative::Derivative))]
@@ -876,6 +880,7 @@ pub enum StreamSource {
 /// let stream_source = serde_json::from_value::<Vec<ArchiveUrl>>(expected).expect("Should deserialize");
 /// assert_eq!(archive_urls, stream_source);
 /// ```
+#[ts_prepare]
 #[derive(Clone, Serialize, Deserialize, PartialEq, Eq)]
 #[serde(from = "ArchiveUrlShort", into = "ArchiveUrlShort")]
 pub struct ArchiveUrl {
@@ -965,6 +970,7 @@ where
     ))
 }
 
+#[ts_prepare]
 #[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct StreamProxyHeaders {
@@ -975,6 +981,7 @@ pub struct StreamProxyHeaders {
 }
 
 /// See <https://github.com/Stremio/stremio-addon-sdk/blob/master/docs/api/responses/stream.md#additional-properties-to-provide-information--behaviour-flags> for documentation
+#[ts_prepare]
 #[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[serde(rename_all = "camelCase")]
 pub struct StreamBehaviorHints {
@@ -993,6 +1000,7 @@ pub struct StreamBehaviorHints {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub video_size: Option<u64>,
     #[serde(flatten)]
+    #[ts(skip)]
     pub other: HashMap<String, serde_json::Value>,
 }
 
diff --git a/src/types/resource/subtitles.rs b/src/types/resource/subtitles.rs
index 91a14772..9ef0e069 100644
--- a/src/types/resource/subtitles.rs
+++ b/src/types/resource/subtitles.rs
@@ -1,8 +1,10 @@
 #[cfg(test)]
 use derivative::Derivative;
 use serde::{Deserialize, Serialize};
+use stremio_derive::ts_prepare;
 use url::Url;
 
+#[ts_prepare]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Debug)]
 #[cfg_attr(test, derive(Derivative))]
 #[cfg_attr(test, derivative(Default))]
diff --git a/src/types/streams/converted_source.rs b/src/types/streams/converted_source.rs
index 5bf048b3..8b3a6005 100644
--- a/src/types/streams/converted_source.rs
+++ b/src/types/streams/converted_source.rs
@@ -1,9 +1,10 @@
 use core::fmt;
 
-use url::Url;
-
 use serde::{Deserialize, Serialize};
 use serde_with::{serde_as, DefaultOnNull};
+use stremio_derive::ts_prepare;
+use ts_rs::TS;
+use url::Url;
 
 use crate::types::{
     resource::{deserialize_stream_source_external, StreamSource},
@@ -11,7 +12,7 @@ use crate::types::{
 };
 
 /// Trait which defines the StreamSource state data structures in Core.
-pub trait StreamSourceTrait: sealed::Sealed {}
+pub trait StreamSourceTrait: sealed::Sealed + TS {}
 
 impl StreamSourceTrait for ConvertedStreamSource {}
 impl sealed::Sealed for ConvertedStreamSource {}
@@ -24,6 +25,7 @@ mod sealed {
     pub trait Sealed {}
 }
 
+#[ts_prepare]
 #[serde_as]
 #[derive(Clone, PartialEq, Eq, Serialize, Deserialize)]
 #[serde(untagged)]
diff --git a/src/types/torrent.rs b/src/types/torrent.rs
index 88c5214b..00cdf03b 100644
--- a/src/types/torrent.rs
+++ b/src/types/torrent.rs
@@ -2,6 +2,7 @@ use core::fmt;
 use std::str::FromStr;
 
 use serde::{Deserialize, Serialize};
+use stremio_derive::ts_prepare;
 use stremio_serde_hex::{SerHex, Strict};
 
 ///
@@ -15,6 +16,7 @@ use stremio_serde_hex::{SerHex, Strict};
 ///
 /// dbg!(info_hash);
 /// ```
+#[ts_prepare]
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
 #[serde(transparent)]
 pub struct InfoHash(#[serde(with = "SerHex::<Strict>")] [u8; 20]);
diff --git a/stremio-core-web/Cargo.toml b/stremio-core-web/Cargo.toml
index aebac989..c1cc5677 100644
--- a/stremio-core-web/Cargo.toml
+++ b/stremio-core-web/Cargo.toml
@@ -29,7 +29,7 @@ futures = "0.3.*"
 
 # used for Env impl
 http = { version = "1.2", optional = true }
-url = { version = "2.4.*", features = ["serde"] }
+url = { version = "^2.4.*", features = ["serde"] }
 
 chrono = "0.4.*"
 semver = { version = "1", features = ["serde"] }
@@ -37,7 +37,7 @@ semver = { version = "1", features = ["serde"] }
 regex = {version = "1.8", optional = true }
 # used for Env impl
 hex = { version = "0.4", optional = true }
-either = "1.6.*"
+either = "^1.6.*"
 enclose = "1.1.*"
 itertools = "0.14.*"
 boolinator = "2.4.*"
@@ -47,7 +47,7 @@ wasm-bindgen = { version = "=0.2.78", features = ["serde-serialize"], optional =
 wasm-bindgen-futures = { version = "0.4", optional = true }
 gloo-utils = { version = "0.2", features = ["serde"], optional = true }
 
-once_cell = "1"
+once_cell = "^1"
 
 # panic hook for wasm
 console_error_panic_hook = { version = "0.1.*", optional = true }
diff --git a/stremio-derive/Cargo.toml b/stremio-derive/Cargo.toml
index e9e3d4e4..e48a192b 100644
--- a/stremio-derive/Cargo.toml
+++ b/stremio-derive/Cargo.toml
@@ -8,7 +8,7 @@ publish = false
 proc-macro = true
 
 [dependencies]
-syn = "2"
+syn = { version = "2", features = ["full", "parsing", "extra-traits"] }
 quote = "1"
 proc-macro2 = "1"
 proc-macro-crate = "1"
diff --git a/stremio-derive/src/lib.rs b/stremio-derive/src/lib.rs
index 6bcbe622..2881fa04 100644
--- a/stremio-derive/src/lib.rs
+++ b/stremio-derive/src/lib.rs
@@ -3,10 +3,13 @@ use proc_macro::TokenStream;
 use proc_macro2::Span;
 use proc_macro_crate::{crate_name, FoundCrate};
 use proc_macro_roids::IdentExt;
-use quote::quote;
+use quote::{quote, ToTokens};
 use std::borrow::Cow;
 use std::{env, iter};
-use syn::{parse_macro_input, Data, DataStruct, DeriveInput, Fields, Ident};
+use syn::{
+    parse_macro_input, parse_quote, Attribute, Data, DataEnum, DataStruct, DeriveInput, Fields,
+    Ident,
+};
 
 const CORE_CRATE_ORIGINAL_NAME: &str = "stremio-core";
 
@@ -146,3 +149,281 @@ fn get_core_ident() -> Result<Ident, proc_macro_crate::Error> {
     };
     Ok(Ident::new(&core_crate_name, Span::call_site()))
 }
+
+/// Attribute macro that prepares a struct or enum for TypeScript export via `ts-rs`.
+///
+/// This macro automatically:
+/// - Adds `TS` to the derive list
+/// - Adds `#[ts(optional_fields)]` to the struct/enum
+/// - Adds `#[ts(as = "Option<_>")]` to fields with `#[serde(default)]` that aren't `Option<T>`
+/// - Adds `#[ts(as = "String")]` to `InfoHash` fields
+/// - Adds `#[ts(as = "_")]` to fields with `#[serde(with = "...")]` or `#[serde_as(as = "...")]`
+///
+/// # Example
+///
+/// ```ignore
+/// #[ts_prepare]
+/// #[derive(Serialize, Deserialize)]
+/// struct MyStruct {
+///     #[serde(default)]
+///     field: String,  // Will get #[ts(as = "Option<_>")] added
+///
+///     #[serde(default)]
+///     opt: Option<i32>,  // Already Option, won't be modified
+///
+///     required: bool,  // No #[serde(default)], won't be modified
+///
+///     hash: InfoHash,  // Will get #[ts(as = "String")] added
+///
+///     #[serde_as(as = "DisplayFromStr")]
+///     custom: MyType,  // Will get #[ts(as = "_")] added
+/// }
+/// ```
+///
+/// # Passing additional ts attributes
+///
+/// You can pass additional `ts` attributes to be added to the struct/enum:
+///
+/// ```ignore
+/// #[ts_prepare(export)]  // Adds #[ts(export)]
+/// #[derive(Serialize, Deserialize)]
+/// struct MyStruct { ... }
+///
+/// #[ts_prepare(export, rename = "MyCustomName")]  // Adds #[ts(export, rename = "MyCustomName")]
+/// #[derive(Serialize, Deserialize)]
+/// struct AnotherStruct { ... }
+/// ```
+#[proc_macro_attribute]
+pub fn ts_prepare(attr: TokenStream, item: TokenStream) -> TokenStream {
+    let mut input = parse_macro_input!(item as DeriveInput);
+
+    // Add any additional ts attributes passed to the macro
+    let attr2: proc_macro2::TokenStream = attr.into();
+    if !attr2.is_empty() {
+        let ts_attr: Attribute = parse_quote!(#[ts(#attr2)]);
+        input.attrs.push(ts_attr);
+    }
+
+    // Add TS to derive if not already present
+    add_ts_derive(&mut input.attrs);
+
+    // Add #[ts(optional_fields)] to the struct/enum if not already present
+    if !has_ts_optional_fields(&input.attrs) {
+        let ts_attr: Attribute = parse_quote!(#[ts(optional_fields)]);
+        input.attrs.push(ts_attr);
+    }
+
+    match &mut input.data {
+        Data::Struct(data_struct) => {
+            process_fields(&mut data_struct.fields);
+        }
+        Data::Enum(data_enum) => {
+            process_enum_variants(data_enum);
+        }
+        Data::Union(_) => {}
+    }
+
+    input.to_token_stream().into()
+}
+
+fn add_ts_derive(attrs: &mut Vec<Attribute>) {
+    for attr in attrs.iter_mut() {
+        if attr.path().is_ident("derive") {
+            // Check if TS is already in the derive list
+            let mut has_ts = false;
+            let _ = attr.parse_nested_meta(|meta| {
+                if meta.path.is_ident("TS") {
+                    has_ts = true;
+                }
+                Ok(())
+            });
+
+            if !has_ts {
+                // Parse the existing derive content and add TS
+                if let syn::Meta::List(meta_list) = &mut attr.meta {
+                    let tokens = &meta_list.tokens;
+                    let new_tokens: proc_macro2::TokenStream = quote!(#tokens, ts_rs::TS);
+                    meta_list.tokens = new_tokens;
+                }
+            }
+            return;
+        }
+    }
+
+    // No derive attribute found, add one with just TS
+    let derive_attr: Attribute = parse_quote!(#[derive(ts_rs::TS)]);
+    attrs.push(derive_attr);
+}
+
+fn process_enum_variants(data_enum: &mut DataEnum) {
+    for variant in &mut data_enum.variants {
+        process_fields(&mut variant.fields);
+    }
+}
+
+fn process_fields(fields: &mut Fields) {
+    let fields_iter = match fields {
+        Fields::Named(named) => named.named.iter_mut(),
+        Fields::Unnamed(unnamed) => unnamed.unnamed.iter_mut(),
+        Fields::Unit => return,
+    };
+
+    for field in fields_iter {
+        // Skip fields that already have #[ts(as = "...")] or have #[serde(flatten)]
+        // (ts(as) is incompatible with flatten)
+        if has_ts_as(&field.attrs) || has_serde_flatten(&field.attrs) {
+            continue;
+        }
+
+        // Add #[ts(as = "String")] for fields with #[serde(with = "SerHex:...")]
+        if has_serde_with_ser_hex(&field.attrs) {
+            let ts_attr: Attribute = parse_quote!(#[ts(as = "String")]);
+            field.attrs.push(ts_attr);
+            continue;
+        }
+
+        // Add #[ts(as = "...")] for OptionsLimit types (newtype wrapper around usize)
+        if is_options_limit_type(field) {
+            let ts_attr: Attribute = if has_serde_default(&field.attrs) {
+                parse_quote!(#[ts(as = "Option<usize>")])
+            } else {
+                parse_quote!(#[ts(as = "usize")])
+            };
+            field.attrs.push(ts_attr);
+            continue;
+        }
+
+        // Add #[ts(as = "_")] for fields with #[serde(with = "...")] or #[serde_as(as = "...")]
+        if has_serde_with(&field.attrs) || has_serde_as(&field.attrs) {
+            let ts_attr: Attribute = if has_serde_default(&field.attrs) {
+                parse_quote!(#[ts(as = "Option<_>")])
+            } else {
+                parse_quote!(#[ts(as = "_")])
+            };
+            field.attrs.push(ts_attr);
+            continue;
+        }
+
+        // Add #[ts(as = "Option<_>")] for fields with #[serde(default)] that aren't Option<T>
+        if has_serde_default(&field.attrs) && !is_option_type(field) {
+            let ts_attr: Attribute = parse_quote!(#[ts(as = "Option<_>")]);
+            field.attrs.push(ts_attr);
+        }
+    }
+}
+
+fn has_serde_default(attrs: &[Attribute]) -> bool {
+    has_serde_attr(attrs, "default")
+}
+
+fn has_serde_flatten(attrs: &[Attribute]) -> bool {
+    has_serde_attr(attrs, "flatten")
+}
+
+fn has_serde_with(attrs: &[Attribute]) -> bool {
+    has_serde_attr(attrs, "with")
+}
+
+fn has_serde_with_ser_hex(attrs: &[Attribute]) -> bool {
+    attrs.iter().any(|attr| {
+        if !attr.path().is_ident("serde") {
+            return false;
+        }
+
+        let mut found = false;
+        let _ = attr.parse_nested_meta(|meta| {
+            if meta.path.is_ident("with") {
+                if let Ok(value) = meta.value() {
+                    if let Ok(lit) = value.parse::<syn::LitStr>() {
+                        if lit.value().starts_with("SerHex:") {
+                            found = true;
+                        }
+                    }
+                }
+            }
+            Ok(())
+        });
+        found
+    })
+}
+
+fn has_serde_as(attrs: &[Attribute]) -> bool {
+    attrs.iter().any(|attr| {
+        if !attr.path().is_ident("serde_as") {
+            return false;
+        }
+
+        let mut found = false;
+        let _ = attr.parse_nested_meta(|meta| {
+            if meta.path.is_ident("as") {
+                found = true;
+            }
+            Ok(())
+        });
+        found
+    })
+}
+
+fn has_serde_attr(attrs: &[Attribute], name: &str) -> bool {
+    attrs.iter().any(|attr| {
+        if !attr.path().is_ident("serde") {
+            return false;
+        }
+
+        let mut found = false;
+        let _ = attr.parse_nested_meta(|meta| {
+            if meta.path.is_ident(name) {
+                found = true;
+            }
+            // Consume any value (e.g., `alias = "stream"`) to allow parsing to continue
+            // to subsequent items in the attribute list
+            if meta.input.peek(syn::Token![=]) {
+                let _ = meta.value()?.parse::<syn::Lit>()?;
+            }
+            Ok(())
+        });
+        found
+    })
+}
+
+fn has_ts_as(attrs: &[Attribute]) -> bool {
+    has_ts_attr(attrs, "as")
+}
+
+fn has_ts_optional_fields(attrs: &[Attribute]) -> bool {
+    has_ts_attr(attrs, "optional_fields")
+}
+
+fn has_ts_attr(attrs: &[Attribute], name: &str) -> bool {
+    attrs.iter().any(|attr| {
+        if !attr.path().is_ident("ts") {
+            return false;
+        }
+
+        let mut found = false;
+        let _ = attr.parse_nested_meta(|meta| {
+            if meta.path.is_ident(name) {
+                found = true;
+            }
+            Ok(())
+        });
+        found
+    })
+}
+
+fn is_option_type(field: &syn::Field) -> bool {
+    is_type_named(field, "Option")
+}
+
+fn is_options_limit_type(field: &syn::Field) -> bool {
+    is_type_named(field, "OptionsLimit")
+}
+
+fn is_type_named(field: &syn::Field, name: &str) -> bool {
+    if let syn::Type::Path(type_path) = &field.ty {
+        if let Some(segment) = type_path.path.segments.last() {
+            return segment.ident == name;
+        }
+    }
+    false
+}
